Youâ€™re not â€œwrongâ€ â€” what youâ€™re seeing is a classic Kendo Grid layout reflow issue:
	â€¢	After you filter, Kendo recalculates rows/data.
	â€¢	When you expand, the detail template actually renders, but the grid/container doesnâ€™t recompute height until a scroll happens (scroll triggers a reflow/resize internally).
	â€¢	Thatâ€™s why â€œscroll â†’ details appearâ€.

âœ… The code you added (forceGridReflow() + ngAfterViewChecked) is fine.
The missing piece is: youâ€™re not setting pendingReflow = true at the moments that matter (filter/dataStateChange/expand).

â¸»

Fix (minimal change): set pendingReflow = true when filtering + when expanding

1) In dataStateChange(...) (filter/sort/page triggers this)

public dataStateChange(state: any): void {
  this.state = state;

  // whatever you do to apply filtering to gridData...
  // this.gridData = process(...)

  this.pendingReflow = true;   // âœ… IMPORTANT
}

2) In onExpand(...)

Right after you set this.dataItem / selected tab etc:

onExpand(event: any) {
  this.dataItem = event?.dataItem;

  this.selectedTab = 'DETAILS';

  // âœ… ensure layout recalculates for detail row
  this.pendingReflow = true;

  // optional but helps if change detection timing is tight
  // this.cdr.detectChanges();
}

You already have ngAfterViewChecked() calling requestAnimationFrame(() => this.forceGridReflow()).
Thatâ€™s perfect â€” it just needs pendingReflow to be turned on when filter/expand happens.

â¸»

Also update ngOnChanges to trigger reflow when parent sends new data

Your current ngOnChanges only handles the toggleDirective. Add this:

ngOnChanges(changes: SimpleChanges): void {
  if (changes['gridData']) {
    this.pendingReflow = true;   // âœ… when parent updates data
  }

  // keep your existing code
  if (changes['gridData'] && changes['gridData'].currentValue?.length > 0 && this.toggleDirective()) {
    setTimeout(() => this.toggleDirective().applyAttributes(), 0);
  }
}


â¸»

If you want the most reliable â€œKendo-nativeâ€ reflow

Instead of only dispatching window resize, call the grid resize too:

private forceGridReflow(): void {
  requestAnimationFrame(() => {
    this.grid?.resize?.();                 // âœ… best if available
    window.dispatchEvent(new Event('resize'));
  });
}


â¸»

Why it only breaks after filter (your exact scenario)

Filtering changes:
	â€¢	row heights
	â€¢	rendered DOM
	â€¢	expansion container height

Kendo sometimes wonâ€™t repaint the detail container until a resize/scroll. Your scroll is just â€œaccidentallyâ€ doing what we need. Weâ€™re making it deterministic.

â¸»

If you paste your dataStateChange() method (just that method), Iâ€™ll drop the pendingReflow exactly where your filtering logic is applied so it compiles first shot.


---------------------------------







Perfect â€” this screenshot tells me exactly why you still see the â€œdetails appear only after scrollâ€ after filtering.

You already have the flag:

private pendingReflow = false;

â€¦but in your dataStateChange(...) you never set it to true, so ngAfterViewChecked() never fires your reflow after a filter/sort/page event.

Do this (1-line fix in the right place)

Add this.pendingReflow = true; at the end of dataStateChange (after you collapse/clear):

public dataStateChange(state: DataStateChangeEvent): void {
  // store filter state if you need it
  this.filter = state.filter ?? { logic: 'and', filters: [] };

  // collapse on filter/sort/page
  this.selectedTab = 'DETAILS';
  this.clearTableResults(true);

  // âœ… this is the missing piece
  this.pendingReflow = true;
}

Thatâ€™s it.

Why this fixes it

After filtering, Kendo updates DOM heights. The detail row is there, but layout doesnâ€™t recalc until scroll/resize. Your ngAfterViewChecked() + forceGridReflow() is the right approach â€” it just wasnâ€™t being triggered because pendingReflow never flips to true on filter.

â¸»

Also make sure you do the same on expand (if not already)

In onExpand(...) (right after setting dataItem), add:

this.pendingReflow = true;


â¸»

If you want, paste your onExpand() (just that method) and Iâ€™ll point out the exact line to place it so you donâ€™t trigger extra reflows.



---------------------------------



Yes â€” thatâ€™s correct. ğŸ‘
And in your current code, the only missing thing is: set pendingReflow = true when filter/sort/page happens (dataStateChange) (and ideally also on expand).

Minimal, correct changes for your repo

1) dataStateChange(...)  âœ… (this is the main fix)
Your screenshot shows:

this.selectedTab = 'DETAILS';
this.clearTableResults(true);

Add one line after that:

public dataStateChange(state: DataStateChangeEvent): void {
  this.filter = state.filter ?? { logic: 'and', filters: [] };

  this.selectedTab = 'DETAILS';
  this.clearTableResults(true);

  this.pendingReflow = true; // âœ… required
}

2) onExpand(...) âœ… (recommended)
Right after you set this.dataItem (and selectedTab), add:

this.pendingReflow = true;


â¸»

About the â€œotherâ€ suggestions you pasted
	â€¢	ngOnChanges pendingReflow for gridData â†’ optional. Only needed if the parent replaces gridData frequently and you still see layout glitches.
	â€¢	this.grid?.resize?.() â†’ nice if available, but your current window.dispatchEvent(new Event('resize')) is usually enough.

Why Iâ€™m not â€œchanging againâ€

Itâ€™s the same solution: you already wired ngAfterViewChecked() + forceGridReflow().
It wonâ€™t run unless pendingReflow becomes true.
Filtering is the moment where that wasnâ€™t happening â€” thatâ€™s why scroll â€œfixesâ€ it.

If you apply just the dataStateChange line and it still happens only after expand, then add it to onExpand too.
